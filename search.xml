<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>volatile关键字使用总结</title>
    <url>/2020/05/13/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>MarkDown语法</title>
    <url>/2020/03/30/MarkDown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="MarkDown语法"><a href="#MarkDown语法" class="headerlink" title="MarkDown语法"></a>MarkDown语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>#(*12345) 一二三四五级标题 </p>
<h2 id="字体设"><a href="#字体设" class="headerlink" title="字体设"></a>字体设</h2><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr>
<p>-–或***</p>
<hr>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="页面内跳转"><a href="#页面内跳转" class="headerlink" title="页面内跳转"></a>页面内跳转</h2><h3 id="注脚1"><a href="#注脚1" class="headerlink" title="注脚1"></a>注脚<a href="注脚">1</a></h3><p>a </p>
]]></content>
  </entry>
  <entry>
    <title>Hadoop简介</title>
    <url>/2020/04/15/Hadoop%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<hr>
<p> title: hadoop简介<br> date: 2020-04-14 14:31:35<br> tags:<br> categories: hadoop</p>
<hr>
<p> 1: 什么是hadoop<br> 一个分布式系统的基础架构，成本低，高效，高可靠，高容错，高拓展，与spark最大的区别在于分别是面向磁盘和面向内存，总的来说spark的计算能力更强<br> 2: hadoop 核心二组件  </p>
<ul>
<li>HDFS:<br>分布式文件系统，高容错，高吞吐的情况下仍能维持低成本<br>m/s结构，一个集群由一个namenode和多个datanode组成  </li>
</ul>
<p>MapReduce </p>
]]></content>
  </entry>
  <entry>
    <title>Mybatis - plus 常用注解</title>
    <url>/2020/04/14/Mybatis%20-%20plus%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="TableId注解（id）"><a href="#TableId注解（id）" class="headerlink" title="TableId注解（id）"></a>TableId注解（id）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@KeySequence</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">entity</span></span>&#123;</span><br><span class="line">    <span class="meta">@TableId</span>(value=<span class="string">"id"</span> type=<span class="string">"IdType.AUTO"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　type 属性：<br>　　　　AUTO：自增（这里的自增设置在mysql数据库中也要同步设置主键为自增，否则会报错）<br>　　　　NONE：该类型为未设置主键类型<br>　　　　INPUT：手动录入<br>　　　　ID_WORKER：默认主键类型，全局唯一ID，Long类型的主键<br>　　　　UUID：自动生成uuid 插入<br>　　　　ID_WORKER_STR：字符串全局唯一ID  </p>
<h3 id="TableField注解（自动填充）"><a href="#TableField注解（自动填充）" class="headerlink" title="TableField注解（自动填充）"></a>TableField注解（自动填充）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField</span>(filel=Field.INSERT)</span><br><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@TableField</span>(filel=Field.INSERT_UPDATE)</span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis与Hibernate对比</title>
    <url>/2020/04/14/Mybatis%E4%B8%8EHibernate%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>###hibernate的优缺点<br>####优点</p>
<ol>
<li>全自动，完全通过对象关系模型来操作数据库，使用完整的javabean映射来生成sql</li>
<li>开发速度快，简单需求无需手写sql</li>
<li>拥有二级缓存（不太好用），可以使用三方缓存</li>
<li>由于全自动，所以对象关系不依赖数据库，数据库移植成本低</li>
<li>日志系统非常的健全，涉及广泛，包括sql记录、关系异常、优化警告、缓存提示、脏数据警告等</li>
<li>由于完全面向对象，通过O/R mapping可以方便快捷的实现复杂的级联删除、更新等操作<br>####缺点</li>
<li>缓存机制的使用限制很多，使用不当不仅效率不会得到提升，还会有脏读幻读的问题</li>
<li>如何设计O/R mapping ,在性能和对象模型之间平衡需要技巧和经验</li>
<li>绝大多数情况下sql是自动生成自动装配的，无法直接维护，hql的功能无法完全取代原生sql，尽管支持原生sql,但操作模式与orm不同<br>###mybatis的优缺点<br>####优点</li>
<li>半自动自动封装查询返回的对象，完美延续sql使用经验，几乎没有上手难度</li>
<li>sql和代码解耦，单独由xml维护</li>
<li>速度比hibernate快</li>
<li>通过xml标签实现对象关系维护，动态sql,数据库字段映射等操作（讲道理这不算啥优点）<br>####缺点</li>
<li>sql依赖数据库，迁移成本巨大</li>
<li>xml中id必须唯一，所以DAO方法不支持重载</li>
<li>实现本质完全依赖sql,开发过程缓慢</li>
<li>完全不支持级联更新，级联删除</li>
<li>日志，约等于没有</li>
<li>动态sql调试十分笨重，标签功能比较简单，可读性比较差</li>
<li>DAO层比较简单，组装对象的工作量比较大</li>
</ol>
]]></content>
      <categories>
        <category>java插件</category>
      </categories>
      <tags>
        <tag>Mybatis,Hibernate;数据库;java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis配置及使用</title>
    <url>/2020/04/14/Mybatis%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>###mybatis的特点（和hibernate对比）</p>
<p>###基础工程构建及配置文件<br>暂略<br>###基础使用<br>####根据数据库反工程化代码<br>使用mybatis-generator-core可以比较方便的根据数据库以及配置文件自动生成model-dao-mapper的代码，非常方便<br>###多级关联查询附带子对象、子列表<br>####使用resultMap</p>
<ol>
<li>sql的拼装和正常sql一致，注意select字段时区分一下数据库字段的查询返回列名，和resultmap中相对应</li>
<li>根据resultmap中配置的属性（association collection ），mybatis会自动将查询返回的结果封装成对象</li>
</ol>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis,Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>git相关问题调试</title>
    <url>/2020/04/14/git%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<ol>
<li>push 失败定位思路:<br>首先在idea中查看terminal中的报错信息，根据报错信息提示内容进行定位<br>另外在链接其他的私有云、仓库、版本管理时，可以注意是否提供错误码或指南<br>（有的会对commit有要求，未符合对应的格式的会被私人订制的仓库拒绝）  </li>
<li>可以通过查看windows凭据来更改git相关账号的鉴权</li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>excel相关</title>
    <url>/2020/04/14/excel%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>1： csv文件被excel打开并编辑后可能会分隔符改变，最骚的是excel读取不到自己改了啥</p>
]]></content>
      <categories>
        <category>其他情况下的奇妙大坑</category>
      </categories>
  </entry>
  <entry>
    <title>ML_lab</title>
    <url>/2020/04/14/git%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>计划搞一个</p>
]]></content>
      <categories>
        <category>ML_lab</category>
      </categories>
  </entry>
  <entry>
    <title>java11相对于java8的新特性</title>
    <url>/2020/05/21/java11%E7%9B%B8%E5%AF%B9%E4%BA%8Ejava8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>##新的语法特性汇总</p>
<ul>
<li>本地变量类型推断</li>
<li>集成httpClient</li>
<li>Collection功能增强</li>
<li>stream功能增强</li>
<li>Optional功能增强</li>
<li>String功能增强</li>
<li>InputStream功能增强<br>###本地变量类型推断<br>java10以后新增了使用var定义的局部变量的写法，实际上被var定义的变量仍是静态类型，而且在编译过程中编译器会去试图推断便令类型<br>推荐使用的场景有:<br>简化泛型声明：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> varList=<span class="keyword">new</span> ArrayList&lt;Map&lt;String, List&lt;Integer&gt;&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span> （<span class="keyword">var</span> varInList:varlist）&#123;</span><br><span class="line"><span class="comment">//其中varInList可以推断出对应的类型是Map&lt;String, List&lt;Integer&gt;&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
作为定义lambda表达式的参数：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;String&gt; predNotNull = (<span class="keyword">var</span> a) -&gt; a != <span class="keyword">null</span> &amp;&amp; a.trim().length() &gt; <span class="number">0</span>;</span><br><span class="line">        String strAfterFilter = Arrays.stream((<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">""</span>, <span class="keyword">null</span>, <span class="string">"x"</span>&#125;))</span><br><span class="line">                .filter(predNotNull)</span><br><span class="line">                .collect(Collectors.joining(<span class="string">","</span>));</span><br></pre></td></tr></table></figure>
###httpClient<br>参考网址：<a href="http://openjdk.java.net/groups/net/httpclient/intro.html" target="_blank" rel="noopener">http://openjdk.java.net/groups/net/httpclient/intro.html</a><br>//todo<br>###Collection增强<br>11中对于三种集合增加了新的静态方法，以list举例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> listImmutable = List.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"><span class="keyword">var</span> listImmutableCopy = List.copyOf(listImmutable);</span><br></pre></td></tr></table></figure>
要注意这两个方法生成的结果都是不可变的集合<br>###stream增强<br>对8中引入的stream的功能进行了强化：</li>
</ul>
<ol>
<li>单个元素直接构造成stream对象(感觉没啥用)  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> size1 = Stream.ofNullable(<span class="keyword">null</span>).count();</span><br><span class="line">System.out.println(size1); <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">long</span> size2 = Stream.ofNullable(<span class="string">""</span>).count();</span><br><span class="line">System.out.println(size2); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li>
<li>dropWhile与takeWhile<br>dropWhile，对于有序的stream，从头开始去掉满足条件的元素，一旦遇到不满足元素的就结束<br>takeWhile，相反<br>需要注意的是这两个操作都是配合有序流操作的，相当于迭代循环遇到元素跳出，而且是依赖流顺序进行执行的</li>
<li>重载iterate方法用于限制无限流范围<br>8中的无限流使用中要在流内增加limit<br>而11中重载了这个方法：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; streamFromJava9 = Stream.iterate(<span class="number">1</span>, t -&gt; t &lt; <span class="number">1000</span>, t -&gt; <span class="number">2</span> * t + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
###Optional增强</li>
<li>给Optional类增加了stream()方法<br>算是对于流式编程的增强吧<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.of(<span class="string">"Hello openJDK11"</span>).stream()</span><br><span class="line">        .flatMap(s -&gt; Arrays.stream(s.split(<span class="string">" "</span>)))</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
###String增强<br>增加了。。。。一堆不是非常关键的糖类方法<br>###InputStream增强<br>和string增强不同，增加了一个核心方法transferTo，直接将输入流传到输出流<br>###模块式开发，交互式编程，单文件源码的直接执行<br>一句话理解这个，就是开始支持类似于python的脚本<br>###支持Unicode10<br>一句话理解：支持了更多的乱七八糟的字符，包括56个新的emoji<br>###新的加密算法<br>RFC7539中指定的ChaCha20和Poly1305两种加密算法，代替RC4。<br>RFC7748定义的密钥协商方案更高效，更安全，JDK增加了两个新的接口XECPublicKey和XECPrivateKey。<br>###<br>参考链接：<br><a href="https://segmentfault.com/a/1190000022654702" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022654702</a></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java8新特性</title>
    <url>/2020/04/14/java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>###Optional</p>
<p>###Stream<br>####流的特点</p>
<ol>
<li>流中不存储元素</li>
<li>流操作不改变源，流的进行中尽管进行了转换操作，但实际源没有改变</li>
<li>流操作是懒惰的，只有实际调用的时候才会执行，这里可能会在debug中用到<br>####流的工作流</li>
<li>流的启动</li>
<li>链式调用</li>
<li>产生结果（终止流）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i= ArrayList&lt;String&gt;().stream()</span><br><span class="line">                .filter(w -&gt; w.getColor() == RED)</span><br><span class="line">                .mapToInt(w -&gt; w.getWeight())</span><br><span class="line">                .sum();</span><br></pre></td></tr></table></figure>
####流的转换</li>
<li>filter()筛选<br>对流进行过滤，通常流中元素会减少，按照（）中的lambda筛选返回true的元素</li>
<li>map()映射<br>对流中的每个对象执行lamdba,每个输入对应一个输出</li>
<li>flatMap()平铺映射<br>每个输入对应一个flat输出</li>
<li>distinc()去重</li>
<li>sort 排序<br>sort()中可以传参Comparator.comparing()<br>####流的拓展和拼接</li>
<li>limit<br>限制返回的个数</li>
<li>skip<br>跳过前n个</li>
<li>concat<br>拼接流  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;a&quot;, &quot;ab&quot;, &quot;ba&quot;, &quot;c&quot;);</span><br><span class="line">List&lt;String&gt; list1 &#x3D; Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;);</span><br><span class="line">Stream.concat(list.stream(), list1.stream())</span><br><span class="line">        .skip(2).limit(2)</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
####关于流操作的结果收集</li>
<li>foreach()遍历流</li>
<li>peek(x-&gt;method())对每一个x执行method并返回流</li>
<li>toArray()<br>无参数的toArray() 返回Object[]<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strings = Arrays.asList(<span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"ab"</span>, <span class="string">"ba"</span>, <span class="string">"c"</span>).stream()</span><br><span class="line">           .filter(x -&gt; x.length() &gt; <span class="number">1</span>)</span><br><span class="line">           .toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></li>
<li>collect<br>collect(Collectors.toList()):list类型<br>collect(Collectors.toSet()):set类型<br>collect(Collectors.toCollection(TreeSet::new));TreeSet类型<br>collect(Collectors.joining())将stream中所有的string拼接成一条<br>collect(Collectors.joining(“,”))以,为分隔符拼接<br>IntSummaryStatistics collect(Collectors.summarizingInt(String::length)):将stream转为可计算的数字类型<br>可选方法：<br>getMax()<br>getAverage()<br>getCount()<br>getMin()<br>getSum()</li>
<li>Match()<br>stream一共有三种match  </li>
</ol>
<ul>
<li>allMatch()</li>
<li>anyMatch()</li>
<li>noneMatch()</li>
</ul>
<ol start="6">
<li>grouping,partitioningBy<br>grouping类似group by,将结果封装成一个Collector&lt;T, ?, Map&lt;K, List&gt;&gt;，其中T是传入的参数类型，K是groupingBy的键。<br>partitioningBy类似grouping,不过结果是返回的是Collector&lt;T, ?, Map&lt;Boolean, List&gt;&gt;，其中T是传入的参数类型。</li>
<li>reduce<br>迭代binaryOperator传入两个参数，返回一个参数并持续迭代遍历整个流</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>ml开源项目实践</title>
    <url>/2020/05/07/ml%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/O-iK3PxBehk3N7fwjrGJeQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/O-iK3PxBehk3N7fwjrGJeQ</a></p>
]]></content>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2020/04/14/kafka%E5%8A%9F%E8%83%BD%E6%B8%85%E5%8D%95/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>模块</th>
<th>功能</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>队列特性</td>
<td>流式数据处理</td>
<td>高吞吐延迟低</td>
</tr>
<tr>
<td></td>
<td>消息处理</td>
<td>支持订阅和发布</td>
</tr>
<tr>
<td></td>
<td>消息存储</td>
<td>提供一个复杂度为0的磁盘存储结构</td>
</tr>
<tr>
<td>行3</td>
<td>line3</td>
<td>column 3</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>中间件使用</category>
      </categories>
  </entry>
  <entry>
    <title>mysql性能调优</title>
    <url>/2020/04/14/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<p>##mysql性能优化思路及方法<br>###思路</p>
<ol>
<li>选择合适的引擎  </li>
<li>正确的配置数据库</li>
<li>SQL 语句优化</li>
<li>表结构优化</li>
<li>索引使用及优化</li>
<li>排序优化</li>
<li>读写事务分离</li>
<li>硬件升级，分布式或者提升配置</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>mysql插入时存在则更新，不存在则新增</title>
    <url>/2020/04/14/mysql%E6%8F%92%E5%85%A5%E6%97%B6%E5%AD%98%E5%9C%A8%E5%88%99%E6%9B%B4%E6%96%B0%EF%BC%8C%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%88%99%E6%96%B0%E5%A2%9E/</url>
    <content><![CDATA[<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> **_TABLE_** ()  </span><br><span class="line"><span class="keyword">values</span>()  </span><br><span class="line">()</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">update</span> </span><br><span class="line">conclume=<span class="keyword">values</span>(conclume)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>spring相关问题</title>
    <url>/2020/04/14/spring%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ol>
<li>spring配置文件不生效<br>检查idea中项目设置中是否在Modules中添加了spring<br>检查项目的maven配置文件中是否指定了配置文件的路径或者将配置文件屏蔽<br>检查配置文件中对应的各个项目名和配置包名是否错误<br>检查是否重写了配置文件加载方法指定了其他的路径</li>
</ol>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2020/05/19/test/</url>
    <content><![CDATA[<p>123</p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
  </entry>
  <entry>
    <title>token,cookie,session,jwt区别</title>
    <url>/2020/04/14/token,cookie,session,jwt%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>####token,cookie,session,jwt区别<br>1: cookie<br>浏览器中永久持有的一个数据，由服务器生成发给浏览器，浏览器以kv的格式存储起来，浏览器本地做了一些限制来防止cookie被篡改，由于是存放在本地的，所以浏览器本身对于每个域下cookie的数量有一定的限制。<br>2: session<br>会话，服务器用session来区分进行会话的用户，客户端每次发送请求时都会带有这个身份标示，客户端有多重存储方式，但一般默认采用cookie的方式。<br>服务器端session是临时存储在服务器上的，用户离开后自动销毁，相对cookie更加安全，但是一个缺点是占用服务器的资源，另一个是如果服务器的处理端做了负载均衡，操作分配到不同的服务器上时可能会session丢失<br>3: token  </p>
<ul>
<li>无状态，可拓展  </li>
<li>支持移动设备  </li>
<li>跨程序调用</li>
<li>安全  </li>
<li>基于token的验证流程如下：<br>用户通过用户名和密码发送请求<br>服务器验证<br>通过后返回签名token<br>客户段存储token，每次发送请求包含token<br>服务端验证token<br>4: jwt<br>json web token,将用户信息加密到token中，服务器端不保存任何客户信息，服务器端通过秘钥验证token的合法性</li>
</ul>
]]></content>
      <categories>
        <category>web知识</category>
      </categories>
  </entry>
  <entry>
    <title>web项目登录验证</title>
    <url>/2020/04/14/web%E9%A1%B9%E7%9B%AE%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p>###web登录</p>
<p>####基于jwt的登录模式<br>#####啥是jwt<br>JSON Web Token（JWT）是一个开放式标准（RFC 7519），它定义了一种紧凑且自包含的方式，用于在各方之间以JSON对象安全传输信息。这些信息可以通过数字签名进行验证和信任。可以使用秘密（使用HMAC算法）或使用RSA的公钥/私钥对对JWT进行签名。<br>或者干脆就理解成Json格式的token<br>#####jwt的优点</p>
<ol>
<li>体积小</li>
</ol>
]]></content>
      <categories>
        <category>web知识</category>
      </categories>
  </entry>
  <entry>
    <title>开发环境搭建</title>
    <url>/2020/04/14/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>#开发环境搭建</p>
<ol>
<li>配置清单<ul>
<li>idea(自带maven,java1.8)无授权建议安装2018版<br><a href="https://www.jetbrains.com/idea/download/other.html" target="_blank" rel="noopener">下载链接</a></li>
<li>java相关(如果没要求就Oracle java,有版权要求就Openjdk,反正都一样能用)<br><a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">下载链接</a></li>
<li>mysql(客户端使用navicat/dbserver)<br><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">mysql下载链接</a></li>
<li>python(建议anacond,管理环境或者其他操作比较方便，ide建议用Pycharm)<br><a href="https://www.python.org/getit/" target="_blank" rel="noopener">python下载</a><br><a href="https://www.anaconda.com/distribution/" target="_blank" rel="noopener">anaconda下载</a><br><a href="https://www.jetbrains.com/pycharm/download/#section=windows" target="_blank" rel="noopener">pycharm下载</a></li>
<li>oracle(超级麻烦，客户端使用plsql)</li>
<li>neo4j(nosql的一种，图数据库)</li>
<li>mangodb(分布式文件存储)</li>
<li>redis(缓存)  </li>
</ul>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title>定时任务</title>
    <url>/2020/04/14/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<hr>
<p> title: java定时任务<br> date: 2020-04-14 14:31:35<br> tags:<br> categories: java</p>
<hr>
<p>java实现定时任务的方法比较多（虽然常用的基本就是quatz或者springtask<br>1: Timer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Timer(<span class="string">"timer"</span>).schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"一个定时任务，延迟一秒启动，每两秒执行一次"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Date date = dateFormat.parse(<span class="string">"2018-07-11 12:00:00.000"</span>);</span><br><span class="line">	<span class="keyword">new</span> Timer(<span class="string">"timer"</span>).scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"一个定时任务，date指定的时间开始执行，每两秒执行一次"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, date,<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2: ScheduledExecutorService<br>个人感觉不好用啊不说了</p>
<p>3: spring提供的注解</p>
<p>{秒} {分} {时} {日期} {月} {星期}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(SpringTask<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"5 * * * * *"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">task1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"springtask 定时任务！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Scheduled</span>(initialDelay = <span class="number">1000</span>,fixedRate = <span class="number">1</span>*<span class="number">1000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">task2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"springtask 定时任务！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4：quartz框架<br>maven依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- quartz --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--调度器核心包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>参考：<a href="https://www.cnblogs.com/zhangbin1989/p/9294114.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangbin1989/p/9294114.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>查询使用group by时规避5.7以上的全group配置</title>
    <url>/2020/04/14/%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8group%20by%E6%97%B6%E8%A7%84%E9%81%BF5.7%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%85%A8group%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_1,column_2,column_3 <span class="keyword">from</span> table_1,  </span><br><span class="line">(<span class="keyword">select</span> column_1,<span class="keyword">max</span>(column_2) <span class="keyword">as</span> maxcol2 <span class="keyword">from</span> table_1 <span class="keyword">group</span> <span class="keyword">by</span> column_1)<span class="keyword">as</span> t  </span><br><span class="line"><span class="keyword">where</span> table_1.column_1=t.column_1 <span class="keyword">and</span> table_1.column_2=t.maxcol2</span><br></pre></td></tr></table></figure>
<p>mysql5.7以上数据库默认配置中有一项group by相关的（默认sql使用group by的时候必须select的字段和group by的字段必须统一），当然是可以用管理员权限的用户去掉这个配置，不过这样就违背了数据库设计的初衷，所以可以通过这样的查询结构来行使查询指定分组的数据</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>Mybatis;Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议相关</title>
    <url>/2020/04/22/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<hr>
<p> title: 网络协议相关<br> date: 2020-04-14 14:31:35<br> tags:<br> categories: 网络协议</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>触发器的坑</title>
    <url>/2020/04/14/%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>触发器语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create trigger triggerName </span><br><span class="line">after&#x2F;before insert&#x2F;update&#x2F;delete on 表名 </span><br><span class="line">for each row #这句话在mysql是固定的 </span><br><span class="line">begin </span><br><span class="line"> sql语句; </span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<ol>
<li>mysql 有部分版本不支持begin/end这个字段</li>
<li>声明触发器前需要声明终止符 DELIMITER $$</li>
<li>有的时候我也不知道为啥创建不成功</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>网络架构问题定位</title>
    <url>/2020/04/14/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<p>1.浏览器日志显示请求响应时间6s,后台日志记录显示3s<br>查看网络中间件日志，如tomcat/nginx等</p>
]]></content>
      <categories>
        <category>问题调试</category>
      </categories>
  </entry>
</search>
